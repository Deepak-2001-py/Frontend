<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="GradeAnt: AI-Powered Homework Grader for students and teachers" />
  <title>GradeAnt: AI-Powered Homework Grader</title>

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../img/favicon.ico" />
  <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon-32x32.png" />
  <link rel="apple-touch-icon" href="../img/apple-touch-icon.png" />

  <!-- Styles -->
  <link rel="stylesheet" href="../css/asthetic_style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="../teacher/teacher_grade.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="../component-loader.js"></script>
</head>
<body>

  <!-- Navigation will be loaded here -->
  <div id="nav"></div>
  <main class="main-content">
    <div class="container">
  
      <section id="grades-section" class="tab-content" role="tabpanel">
        <div class="card">
          <div class="card-header">
            <h2><i class="fas fa-chart-bar"></i> View Grades</h2>
          </div>
          <div class="card-body">
            <nav class="secondary-nav" aria-label="User Type Navigation">
              <ul class="nav-tabs" role="tablist">
                <li role="presentation">
                  <button class="tab-btn active" id="student-view-btn" data-tab="student-view" aria-selected="true">
                    <i class="fas fa-user-graduate"></i> Single Student's Assignment Info View
                  </button>
                </li>
              </ul>
            </nav>
            
            <h1>Student Assignment Details</h1>
            
            <div id="student-view" class="sub-tab-content active">
              <div class="loader-container" id="student-loader-container">
                <div class="loader" id="student-loader"></div>
              </div>
                            <h4>Question Breakdown</h4>
                <div id="questions-container"></div>
                
                <button class="print-button" onclick="window.print()">print</button>
    <style>
/* ========================================
   Professional Grade Management System Styles
   ======================================== */

:root {
  --primary-color: #3db6ee;
  --primary-hover: #1d4ed8;
  --success-color: #15c98d;
  --success-hover: #059669;
  --warning-color: #f59e0b;
  --warning-hover: #d97706;
  --danger-color: #ef4444;
  --danger-hover: #dc2626;
  --neutral-50: #f8fafc;
  --neutral-100: #f1f5f9;
  --neutral-200: #e2e8f0;
  --neutral-300: #cbd5e1;
  --neutral-400: #94a3b8;
  --neutral-500: #64748b;
  --neutral-600: #475569;
  --neutral-700: #334155;
  --neutral-800: #ff7b00;
  --neutral-900: #0f172a;
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --gradient-success: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
  --gradient-warning: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  --gradient-danger: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
}

/* Base Layout Improvements */
.result-container {
  margin: 32px auto;
  max-width: 1400px;
  padding: 32px;
  border: none;
  border-radius: 20px;
  background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
  box-shadow: var(--shadow-xl);
  position: relative;
  overflow: hidden;
  animation: slideInUp 0.6s ease-out;
}

.result-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: var(--gradient-primary);
  animation: shimmer 2s ease-in-out infinite;
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes shimmer {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Enhanced Summary Table */
.summary-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  margin: 32px 0;
  background: linear-gradient(145deg, #ffffff, #f8fafc);
  border-radius: 16px;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  animation: fadeInScale 0.8s ease-out 0.2s both;
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.summary-table th {
  background: var(--gradient-primary);
  color: white;
  font-weight: 700;
  padding: 20px 16px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 13px;
  border: none;
  position: relative;
  overflow: hidden;
}

.summary-table th::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  transition: left 0.5s;
}

.summary-table th:hover::before {
  left: 100%;
}

.summary-table td {
  padding: 20px 16px;
  border-bottom: 1px solid var(--neutral-200);
  transition: all 0.3s ease;
  position: relative;
}

.summary-table tr {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.summary-table tbody tr:hover {
  background: linear-gradient(90deg, var(--neutral-50), white);
  transform: translateX(4px);
  box-shadow: 0 4px 20px rgba(37, 99, 235, 0.1);
}

.summary-table tbody tr:hover td {
  border-color: var(--primary-color);
}

/* Sophisticated Input Styling */
.marks-input {
  width: 100px;
  padding: 12px 16px;
  border: 2px solid var(--neutral-200);
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  background: linear-gradient(145deg, #ffffff, #f8fafc);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: var(--shadow-sm);
  text-align: center;
}

.marks-input:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1), var(--shadow-md);
  transform: translateY(-2px);
  background: white;
}

.marks-input:hover {
  border-color: var(--primary-hover);
  transform: translateY(-1px);
}

/* Premium Button Styles */
.edit-marks-btn, .edit-question-marks-btn {
  background: var(--gradient-primary);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 25px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
}

.edit-marks-btn::before, .edit-question-marks-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  transition: left 0.5s;
}

.edit-marks-btn:hover, .edit-question-marks-btn:hover {
  transform: translateY(-3px) scale(1.05);
  box-shadow: var(--shadow-xl);
}

.edit-marks-btn:hover::before, .edit-question-marks-btn:hover::before {
  left: 100%;
}

.edit-marks-btn.save-mode, .edit-question-marks-btn.save-mode {
  background: var(--gradient-success);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { box-shadow: var(--shadow-md); }
  50% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4), var(--shadow-md); }
}

.edit-marks-btn:active, .edit-question-marks-btn:active {
  transform: translateY(-1px) scale(1.02);
  transition: all 0.1s ease;
}

/* Hero Action Buttons */
.print-button, .update-marks-button {
  background: var(--gradient-success);
  color: white;
  border: none;
  padding: 16px 32px;
  border-radius: 50px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin: 24px 12px 24px 0;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
  min-width: 180px;
}

.print-button::before, .update-marks-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  transition: left 0.6s;
}

.print-button:hover, .update-marks-button:hover {
  transform: translateY(-4px) scale(1.05);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(16, 185, 129, 0.3);
}
.update-marks-button:hover {
  transform: translateY(-4px) scale(1.05);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(16, 185, 129, 0.3);
}


.print-button:hover::before, .update-marks-button:hover::before {
  left: 100%;
}

.print-button:disabled, .update-marks-button:disabled {
  background: linear-gradient(135deg, var(--neutral-400), var(--neutral-500));
  cursor: not-allowed;
  transform: none;
  animation: none;
}

/* Stunning Alert System */
.custom-alert {
  padding: 20px 24px;
  border-radius: 16px;
  margin-bottom: 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-weight: 600;
  box-shadow: var(--shadow-lg);
  border: none;
  position: relative;
  overflow: hidden;
  animation: slideInRight 0.5s ease-out;
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(50px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.custom-alert::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  animation: expandHeight 0.5s ease-out 0.1s both;
}

@keyframes expandHeight {
  from { height: 0; }
  to { height: 100%; }
}

.alert-success {
  background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
  color: var(--success-hover);
  border-left: 4px solid var(--success-color);
}

.alert-success::before {
  background: var(--success-color);
}

.alert-danger {
  background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
  color: var(--danger-hover);
  border-left: 4px solid var(--danger-color);
}

.alert-danger::before {
  background: var(--danger-color);
}

.alert-warning {
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  color: var(--warning-hover);
  border-left: 4px solid var(--warning-color);
}

.alert-warning::before {
  background: var(--warning-color);
}

.alert-info {
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
  color: var(--primary-hover);
  border-left: 4px solid var(--primary-color);
}

.alert-info::before {
  background: var(--primary-color);
}

.alert-close {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 16px;
  cursor: pointer;
  padding: 0;
  margin-left: 16px;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(10px);
}

.alert-close:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: rotate(90deg) scale(1.1);
}

/* Enhanced Typography */
h4 {
  color: #ff7b00;
  margin-bottom: 24px;
  font-size: 20px;
  font-weight: 800;
  background: var(--gradient-primary);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  position: relative;
  display: inline-block;
}

h4::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 0;
  width: 60px;
  height: 4px;
  background: var(--gradient-primary);
  border-radius: 2px;
  animation: expandWidth 0.8s ease-out 0.3s both;
}

@keyframes expandWidth {
  from { width: 0; }
  to { width: 60px; }
}

/* Sophisticated Marks Display */
.marks-display {
  font-weight: 800;
  font-size: 18px;
  color: var(--primary-color);
  background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: 0 2px 4px rgba(37, 99, 235, 0.1);
  transition: all 0.3s ease;
}

.obtained-marks-container {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: linear-gradient(145deg, var(--neutral-50), white);
  border-radius: 12px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s ease;
  min-width: 80px;
  justify-content: center;
}

.obtained-marks-container:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

/* Question Item Enhancements */
.question-item {
  background: linear-gradient(145deg, #ffffff, #f8fafc);
  border-radius: 20px;
  padding: 32px;
  margin-bottom: 32px;
  box-shadow: var(--shadow-lg);
  border: 1px solid var(--neutral-200);
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
  animation: fadeInUp 0.6s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.question-item::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: var(--gradient-primary);
  transform: scaleX(0);
  transform-origin: left;
  transition: transform 0.3s ease;
}

.question-item:hover {
  transform: translateY(-8px);
  box-shadow: var(--shadow-xl);
  border-color: var(--primary-color);
}

.question-item:hover::before {
  transform: scaleX(1);
}

.question-header h3 {
  color: var(--neutral-800);
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 16px;
  background: var(--gradient-primary);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.question-meta {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 24px;
  padding: 16px;
  background: linear-gradient(135deg, var(--neutral-50), white);
  border-radius: 12px;
  border-left: 4px solid var(--primary-color);
}

.timestamp {
  font-size: 14px;
  color: var(--neutral-500);
  font-weight: 500;
  padding: 6px 12px;
  background: var(--neutral-100);
  border-radius: 20px;
}

/* Loading Animation */
@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--neutral-200);
  border-top: 4px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

/* Responsive Design */
@media (max-width: 768px) {
  .result-container {
    margin: 16px;
    padding: 24px 16px;
    border-radius: 16px;
  }
  
  .summary-table {
    font-size: 14px;
  }
  
  .summary-table th,
  .summary-table td {
    padding: 12px 8px;
  }
  
  .print-button, .update-marks-button {
    width: 100%;
    margin: 12px 0;
  }
  
  .question-item {
    padding: 20px 16px;
    margin-bottom: 20px;
  }
  
  .question-meta {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }
}

/* Accessibility Improvements */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
  :root {
    --neutral-50: #0f172a;
    --neutral-100: #1e293b;
    --neutral-200: #334155;
    --neutral-800: #659fda;
    --neutral-900: #f8fafc;
  }
  
  .result-container,
  .summary-table,
  .question-item {
    background: linear-gradient(145deg, #1e293b, #334155);
    color: var(--neutral-100);
  }
}
    </style>
</head>
<body>
    <div class="result-container" id="student-result" style="display: none;">
        <h4>Your Assignment Summary</h4>
        <table id="summary-table" class="summary-table">
            <thead>
                <tr>
                    <th>Student ID</th>
                    <th>Assignment ID</th>
                    <th>Total Marks</th>
                    <th>Evaluation ID</th>
                    <th>QP ID</th>
                    <th>Date</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="summary-body"></tbody>
        </table>
        <button class="update-marks-button" onclick=handleUpdateMarks()>Update Marks</button>
    </div>

<!-- <script src="../javascript/student-details.js"></script> -->
 
<script>
const CONFIG = {
  API: {
    GRADES_ENDPOINT: "https://rus9nultj9.execute-api.eu-north-1.amazonaws.com/dev/getgrades",
    UPDATE_ENDPOINT: "https://rus9nultj9.execute-api.eu-north-1.amazonaws.com/dev/updatedb"
  }
};

function showLoading(id) {
  const element = document.getElementById(id);
  if (element) {
    element.style.display = "block";
  }
}

function hideLoading(id) {
  const element = document.getElementById(id);
  if (element) {
    element.style.display = "none";
  }
}

async function makeAPIRequest(data) {
  try {
    const response = await fetch(CONFIG.API.GRADES_ENDPOINT, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error("API request failed:", error);
    throw error;
  }
}

function getQueryParams() {
  const params = new URLSearchParams(window.location.search);
  return {
    student_id: params.get("student_id"),
    assignment_id: params.get("assignment_id"),
    qp_id: params.get("qp_id"),
    operation: "getSingleStudentGrade"
  };
}

// Store original data for updates
let currentStudentData = null;

// Utility function to escape HTML
function escapeHtml(text) {
  if (typeof text !== 'string') return text;
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Enhanced alert function with better styling
function showAlert(message, type = 'info') {
  // Remove existing alerts
  const existingAlert = document.querySelector('.custom-alert');
  if (existingAlert) {
    existingAlert.remove();
  }

  const alert = document.createElement('div');
  alert.className = `custom-alert alert-${type}`;
  alert.innerHTML = `
    <span>${escapeHtml(message)}</span>
    <button class="alert-close" onclick="this.parentElement.remove()">×</button>
  `;
  
  // Add basic styling
  alert.style.cssText = `
    padding: 12px 20px;
    margin: 10px 0;
    border-radius: 6px;
    position: relative;
    font-size: 14px;
    background-color: ${type === 'danger' ? '#f8d7da' : type === 'warning' ? '#fff3cd' : type === 'success' ? '#d4edda' : '#d1ecf1'};
    color: ${type === 'danger' ? '#721c24' : type === 'warning' ? '#856404' : type === 'success' ? '#155724' : '#0c5460'};
    border: 1px solid ${type === 'danger' ? '#f5c6cb' : type === 'warning' ? '#ffeaa7' : type === 'success' ? '#c3e6cb' : '#bee5eb'};
    z-index: 1000;
  `;
  
  // Style the close button
  const closeBtn = alert.querySelector('.alert-close');
  if (closeBtn) {
    closeBtn.style.cssText = `
      position: absolute;
      top: 8px;
      right: 12px;
      background: none;
      border: none;
      font-size: 18px;
      font-weight: bold;
      color: inherit;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    `;
  }
  
  // Insert at the top of the student result container or body
  const container = document.getElementById('student-result') || document.body;
  if (container) {
    container.insertBefore(alert, container.firstChild);
  }

  // Auto-remove after 5 seconds
  setTimeout(() => {
    if (alert.parentElement) {
      alert.remove();
    }
  }, 5000);
}

function displayStudentSummary(data) {
  const summaryBody = document.getElementById("summary-body");
  const studentResultContainer = document.getElementById("student-result");

  if (!summaryBody || !studentResultContainer) {
    console.error("Required DOM elements not found");
    return;
  }

  summaryBody.innerHTML = "";

  let result;
  if (data && data.body) {
    try {
      result = typeof data.body === 'string' ? JSON.parse(data.body) : data.body;
    } catch (error) {
      console.error("Parse error:", error);
      showAlert("Failed to parse grade data", "danger");
      return;
    }
  } else {
    result = data;
  }

  if (!result || !result.summary || !Array.isArray(result.summary)) {
    showAlert("No summary data available", "warning");
    return;
  }

  // Store the current data for updates
  currentStudentData = result;

  result.summary.forEach((grade, index) => {
    const row = document.createElement("tr");
    const dateStr = grade.timestamp
      ? new Date(grade.timestamp * 1000).toLocaleString()
      : "N/A";
    
    row.innerHTML = `
      <td>${escapeHtml(grade.student_id || "N/A")}</td>
      <td>${escapeHtml(grade.assignment_id || "N/A")}</td>
      <td>
        <span class="marks-display" id="summary-marks-${index}">${grade.total_marks !== undefined && grade.total_marks !== null ? grade.total_marks : "N/A"}</span>
        <input type="number" class="marks-input" id="summary-input-${index}" value="${grade.total_marks || 0}" style="display: none;" min="0" max="100">
      </td>
      <td>${escapeHtml(grade.evaluation_id || "N/A")}</td>
      <td>${escapeHtml(grade.qp_id || "N/A")}</td>
      <td>${escapeHtml(dateStr)}</td>
      <td>
        <button class="edit-marks-btn" onclick="toggleSummaryEditMode(${index})" data-index="${index}">Edit</button>
      </td>
    `;
    summaryBody.appendChild(row);
  });
  
  studentResultContainer.style.display = "block";
  

}

function toggleSummaryEditMode(index) {
  const marksDisplay = document.getElementById(`summary-marks-${index}`);
  const marksInput = document.getElementById(`summary-input-${index}`);
  const editBtn = document.querySelector(`[data-index="${index}"]`);
  
  if (!marksDisplay || !marksInput || !editBtn) {
    console.error("Summary edit elements not found");
    return;
  }
  
  if (marksDisplay.style.display !== "none") {
    // Switch to edit mode
    marksDisplay.style.display = "none";
    marksInput.style.display = "inline-block";
    marksInput.focus();
    editBtn.textContent = "Save";
    editBtn.classList.add("save-mode");
  } else {
    // Switch back to display mode and update the data
    const newValue = parseFloat(marksInput.value) || 0;
    marksDisplay.textContent = newValue;
    marksDisplay.style.display = "inline";
    marksInput.style.display = "none";
    editBtn.textContent = "Edit";
    editBtn.classList.remove("save-mode");
    
    // Update the stored data
    if (currentStudentData && currentStudentData.summary && currentStudentData.summary[index]) {
      currentStudentData.summary[index].total_marks = newValue;
    }
  }
}

// Function to calculate total marks from individual question marks
function calculateTotalMarks() {
  if (!currentStudentData || !currentStudentData.details) {
    return 0;
  }
  
  let totalMarks = 0;
  currentStudentData.details.forEach(question => {
    totalMarks += parseFloat(question.marks || 0);
  });
  
  return totalMarks;
}

// Function to update summary total marks when individual question marks change
function updateSummaryTotalMarks() {
  const newTotalMarks = calculateTotalMarks();
  
  // Update in current data
  if (currentStudentData && currentStudentData.summary && currentStudentData.summary[0]) {
    currentStudentData.summary[0].total_marks = newTotalMarks;
  }
  
  // Update in UI
  const summaryMarksDisplay = document.getElementById('summary-marks-0');
  const summaryMarksInput = document.getElementById('summary-input-0');
  
  if (summaryMarksDisplay) {
    summaryMarksDisplay.textContent = newTotalMarks;
  }
  if (summaryMarksInput) {
    summaryMarksInput.value = newTotalMarks;
  }
  
  // Show notification about auto-update
  showAlert(`Total marks automatically updated to ${newTotalMarks}`, "success");
}

// Function to toggle edit mode for individual question marks
function toggleQuestionEditMode(questionIndex) {
  const marksDisplay = document.getElementById(`question-marks-${questionIndex}`);
  const marksInput = document.getElementById(`question-input-${questionIndex}`);
  const editBtn = document.querySelector(`[data-question-index="${questionIndex}"]`);
  
  if (!marksDisplay || !marksInput || !editBtn) {
    console.error("Question edit elements not found");
    return;
  }
  
  if (marksDisplay.style.display !== "none") {
    // Switch to edit mode
    marksDisplay.style.display = "none";
    marksInput.style.display = "inline-block";
    marksInput.focus();
    editBtn.textContent = "Save";
    editBtn.classList.add("save-mode");
  } else {
    // Switch back to display mode and update the data
    const newValue = parseFloat(marksInput.value) || 0;
    const maxMarks = parseFloat(marksInput.getAttribute('data-max-marks')) || 100;
    
    // Validate marks don't exceed maximum
    if (newValue > maxMarks) {
      showAlert(`Marks cannot exceed maximum of ${maxMarks}`, "warning");
      marksInput.value = maxMarks;
      return;
    }
    
    if (newValue < 0) {
      showAlert("Marks cannot be negative", "warning");
      marksInput.value = 0;
      return;
    }
    
    marksDisplay.textContent = newValue;
    marksDisplay.style.display = "inline";
    marksInput.style.display = "none";
    editBtn.textContent = "Edit";
    editBtn.classList.remove("save-mode");
    
    // Update the stored data
    if (currentStudentData && currentStudentData.details && currentStudentData.details[questionIndex]) {
      currentStudentData.details[questionIndex].marks = newValue;
      
      // Automatically update total marks in summary
      updateSummaryTotalMarks();
    }
  }
}


async function handleUpdateMarks() {
  console.log('Update marks function called');

  if (!currentStudentData || !currentStudentData.summary) {
    showAlert("No data available to update", "warning");
    return;
  }

  // REPLACE the complex button finding logic with simple selector:
  const updateBtn = document.querySelector('.update-marks-button');

  if (!updateBtn) {
    console.error("Update button not found");
    showAlert("Update button not found", "warning");
    return;
  }

  const originalText = updateBtn.textContent;
  
  try {
    // Show loading state
    updateBtn.textContent = "Updating...";
    updateBtn.disabled = true;
    updateBtn.style.cursor = "not-allowed";

    console.log('Preparing data for update...');
    
    // Prepare the data for API call including both summary and details
    const updatedData = {
      
      operation: "updateMarks",
      summary: currentStudentData.summary.map(grade => ({
        student_id: grade.student_id,
        assignment_id: grade.assignment_id,
        evaluation_id: grade.evaluation_id,
        qp_id: grade.qp_id,
        total_marks: grade.total_marks,
        timestamp: grade.timestamp
      })),
      details: currentStudentData.details ? currentStudentData.details.map(question => ({
        question_number: question.question_number,
        subpart: question.subpart,
        marks: question.marks,
        max_marks: question.max_marks,
        timestamp: question.timestamp,
        evaluation_id: question.evaluation_id,
      })) : []
    };

    console.log('Data prepared:', updatedData);

    // Make API call to update marks
    const response = await updateMarksAPI(updatedData);
    
    console.log('updateMarksAPI response:', response);
    
    if (response && (response.success || response.statusCode === 200)) {
      showAlert("All marks updated successfully!", "success");
      // Optionally refresh the data
      await refreshStudentData();
      console.log('Marks updated successfully, data refreshed');
    } else {
      throw new Error(response?.message || response?.error || "Update failed");
    }

  } catch (error) {
    console.error("Update error:", error);
    showAlert(`Failed to update marks: ${error.message}`, "danger");
  } finally {
    // Restore button state
    updateBtn.textContent = originalText;
    updateBtn.disabled = false;
    updateBtn.style.cursor = "pointer";
  }
}

// API call function for updating marks
async function updateMarksAPI(data) {
  console.log('Making API call to update marks...');
  console.log('API Endpoint:', CONFIG.API.UPDATE_ENDPOINT);
  console.log('Payload:', data);
  
  try {
    const payload = data // Add operation type for API to handle updates
    ;
    
    console.log('Final payload:', payload);
    
    const response = await fetch(CONFIG.API.UPDATE_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
        // Add authentication headers if needed
        // 'Authorization': `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify(payload)
    });

    console.log('Response status:', response.status);
    console.log('Response ok:', response.ok);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Response error text:', errorText);
      throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    console.log('updateMarksAPI Response:', result);
    return result;

  } catch (error) {
    console.error('API call failed:', error);
    
    // If it's a network error, provide more specific information
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new Error('Network error: Please check your internet connection and try again.');
    }
    
    throw error;
  }
}

// Function to refresh data after update
async function refreshStudentData() {
  try {
    const queryParams = getQueryParams();
    const data = await makeAPIRequest(queryParams);
    console.log('Data refreshed:', data);
    if (!data || !data.body) {
      showAlert("No data returned from server", "warning");
      return;
    }
    displayStudentSummary(data);
    displayDetails(data);
  } catch (error) {
    console.error('Failed to refresh data:', error);
    showAlert('Failed to refresh data after update', 'warning');
  }
}

// Utility function to get auth token (customize based on your auth system)
function getAuthToken() {
  // Return your authentication token
  // This could be from memory variables, cookies, etc.
  return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
}

// Function to render content with proper formatting
function renderContent(text) {
  if (!text) return '';
  
  // Handle LaTeX format with sections
  if (text.includes('\\textbf{') && text.includes('}:} \\quad \\text{')) {
    const sections = text.match(/\[ \\textbf\{([^}]+)\}\:} \\quad \\text\{([^}]+)\} \]/g) || [];
    
    if (sections.length > 0) {
      const parsedHtml = sections.map(section => {
        const headingMatch = section.match(/\\textbf\{([^}]+)\}/);
        const contentMatch = section.match(/\\quad \\text\{([^}]+)\}/);
        
        const heading = headingMatch ? escapeHtml(headingMatch[1]) : '';
        let content = contentMatch ? contentMatch[1] : '';
        
        content = content.replace(/\\begin\{itemize\}(.*?)\\end\{itemize\}/gs, (match, items) => {
          const listItems = items.split('\\item').filter(item => item.trim());
          return `<ul>${listItems.map(item => `<li>${escapeHtml(item.trim())}</li>`).join('')}</ul>`;
        });
        
        content = content.replace(/\\([a-zA-Z]+)/g, '\\$1');
        content = content.replace(/\\\(([^)]+)\\\)/g, '$$1$');
        
        return `
          <div class="feedback-section">
            <h4>${heading}:</h4>
            <div class="feedback-content">${content}</div>
          </div>
        `;
      }).join('');
      
      return parsedHtml;
    }
  }
  
  // Process Markdown formatting
  let processedText = escapeHtml(text);
  
  processedText = processedText.replace(/^(\d+)\.\s*\*\*(.*?)\*\*/gm, '<br>$1. <strong>$2</strong>');
  processedText = processedText.replace(/^-\s*\*\*(.*?)\*\*/gm, '<br>- <strong>$1</strong>');
  processedText = processedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  processedText = processedText.replace(/^## (.*?)$/gm, '<br><h2>$1</h2>');
  processedText = processedText.replace(/^### (.*?)$/gm, '<br><h3>$1</h3>');
  
  return processedText;
}

// Function to display question details with editable marks
function displayDetails(data) {
  const questionsContainer = document.getElementById("questions-container");

  if (!questionsContainer) {
    console.error("Questions container not found");
    return;
  }

  questionsContainer.innerHTML = "";

  let result;
  if (data && data.body) {
    try {
      result = typeof data.body === 'string' ? JSON.parse(data.body) : data.body;
    } catch (error) {
      console.error("Parse error:", error);
      showAlert("Failed to parse details data", "danger");
      return;
    }
  } else {
    result = data;
  }

  if (!result || !result.details || !Array.isArray(result.details)) {
    console.log("No details available");
    return;
  }

  // Sort questions by question_number
  result.details.sort((a, b) => {
    const numA = parseInt(a.question_number) || 0;
    const numB = parseInt(b.question_number) || 0;
    
    if (numA !== numB) return numA - numB;
    
    if (a.subpart && b.subpart) {
      return a.subpart.localeCompare(b.subpart);
    } else if (a.subpart) {
      return 1;
    } else if (b.subpart) {
      return -1;
    }
    
    return 0;
  });

  result.details.forEach((question, questionIndex) => {
    const questionCard = document.createElement('div');
    questionCard.className = 'question-item';
    
    let timestamp = '';
    if (question.timestamp) {
      try {
        timestamp = new Date(question.timestamp * 1000).toLocaleString();
      } catch (e) {
        console.error("Invalid timestamp format", e);
        timestamp = '';
      }
    }
    
    questionCard.innerHTML = `
      <div class="question-header">
        <h3>Question ${escapeHtml(question.question_number || '')} ${question.subpart ? `(${escapeHtml(question.subpart)})` : ''}</h3>
      </div>
      
      <div class="question-meta">
        <span class="marks">
          Marks: 
          <span class="obtained-marks-container">
            <span class="marks-display" id="question-marks-${questionIndex}">${question.marks || 0}</span>
            <input type="number" 
                   class="marks-input" 
                   id="question-input-${questionIndex}" 
                   value="${question.marks || 0}" 
                   data-max-marks="${question.max_marks || 100}"
                   style="display: none;" 
                   min="0" 
                   max="${question.max_marks || 100}">
          </span>
          / <span class="max">${question.max_marks || 0}</span>
          <button class="edit-question-marks-btn" 
                  onclick="toggleQuestionEditMode(${questionIndex})" 
                  data-question-index="${questionIndex}"
                  style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Edit</button>
        </span>
        ${timestamp ? `<span class="timestamp">Answered on: ${escapeHtml(timestamp)}</span>` : ''}
      </div>

      <p class="question-text">${renderContent(question.question || 'Question not available')}</p>

      <div class="answer-section">
        <h4>Your Answer:</h4>
        <pre>${renderContent(question.student_answer || 'No answer provided')}</pre>
      </div>

      <div class="reasoning-section rubric">
        <h4>Feedback:</h4>
        <div class="feedback-container">${renderContent(question.feedback || 'No additional reasoning provided')}</div>
      </div>
    `;

    questionsContainer.appendChild(questionCard);
  });

  // Load MathJax if needed
  loadMathJax(questionsContainer);
}

function loadMathJax(container) {
  if (!window.MathJax) {
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        processEscapes: true
      },
      options: {
        enableMenu: false,
        processHtmlClass: 'math'
      }
    };
    
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js';
    script.async = true;
    document.head.appendChild(script);
    
    script.onload = function() {
      if (window.MathJax && window.MathJax.typeset) {
        window.MathJax.typeset([container]);
      }
    };
  } else {
    if (window.MathJax && window.MathJax.typeset) {
      window.MathJax.typeset([container]);
    }
  }
}

function setupNavLinkHighlighting() {
  // Implementation depends on your navigation structure
  console.log('Navigation highlighting setup');
}

async function loadAndDisplayData() {
  const queryParams = getQueryParams();
  
  if (!queryParams.student_id || !queryParams.assignment_id) {
    showAlert("Missing required parameters: student_id or assignment_id", "danger");
    return;
  }

  showLoading("student-loader-container");

  try {
    const data = await makeAPIRequest(queryParams);
    displayStudentSummary(data);
    displayDetails(data);
  } catch (error) {
    console.error("Error loading data:", error);
    showAlert(`Failed to load data: ${error.message}`, "danger");
  } finally {
    hideLoading("student-loader-container");
  }
}

// Initialize when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  console.log('DOM Content Loaded - Initializing application...');
  setupNavLinkHighlighting();
  loadAndDisplayData();
});

// Also add a fallback initialization in case DOMContentLoaded has already fired
if (document.readyState === 'loading') {
  // DOM is still loading
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  // DOM has already loaded
  initializeApp();
}

function initializeApp() {
  console.log('Initializing application...');
  setupNavLinkHighlighting();
  loadAndDisplayData();
}

</script>
</body>
</html>
<!-- <script>
const CONFIG = {
  API: {
    GRADES_ENDPOINT: "https://rus9nultj9.execute-api.eu-north-1.amazonaws.com/dev/getgrades",
    UPDATE_ENDPOINT: "https://rus9nultj9.execute-api.eu-north-1.amazonaws.com/dev/updatedb"
  }
};

function showLoading(id) {
  const element = document.getElementById(id);
  if (element) {
    element.style.display = "block";
  }
}

function hideLoading(id) {
  const element = document.getElementById(id);
  if (element) {
    element.style.display = "none";
  }
}

async function makeAPIRequest(data) {
  try {
    const response = await fetch(CONFIG.API.GRADES_ENDPOINT, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error("API request failed:", error);
    throw error;
  }
}

function getQueryParams() {
  const params = new URLSearchParams(window.location.search);
  return {
    student_id: params.get("student_id"),
    assignment_id: params.get("assignment_id"),
    qp_id: params.get("qp_id"),
    operation: "getSingleStudentGrade"
  };
}

// Store original data for updates
let currentStudentData = null;

// Utility function to escape HTML
function escapeHtml(text) {
  if (typeof text !== 'string') return text;
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Enhanced alert function with better styling
function showAlert(message, type = 'info') {
  // Remove existing alerts
  const existingAlert = document.querySelector('.custom-alert');
  if (existingAlert) {
    existingAlert.remove();
  }

  const alert = document.createElement('div');
  alert.className = `custom-alert alert-${type}`;
  alert.innerHTML = `
    <span>${escapeHtml(message)}</span>
    <button class="alert-close" onclick="this.parentElement.remove()">×</button>
  `;
  
  // Add basic styling
  alert.style.cssText = `
    padding: 12px 20px;
    margin: 10px 0;
    border-radius: 6px;
    position: relative;
    font-size: 14px;
    background-color: ${type === 'danger' ? '#f8d7da' : type === 'warning' ? '#fff3cd' : type === 'success' ? '#d4edda' : '#d1ecf1'};
    color: ${type === 'danger' ? '#721c24' : type === 'warning' ? '#856404' : type === 'success' ? '#155724' : '#0c5460'};
    border: 1px solid ${type === 'danger' ? '#f5c6cb' : type === 'warning' ? '#ffeaa7' : type === 'success' ? '#c3e6cb' : '#bee5eb'};
    z-index: 1000;
  `;
  
  // Style the close button
  const closeBtn = alert.querySelector('.alert-close');
  if (closeBtn) {
    closeBtn.style.cssText = `
      position: absolute;
      top: 8px;
      right: 12px;
      background: none;
      border: none;
      font-size: 18px;
      font-weight: bold;
      color: inherit;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    `;
  }
  
  // Insert at the top of the student result container or body
  const container = document.getElementById('student-result') || document.body;
  if (container) {
    container.insertBefore(alert, container.firstChild);
  }

  // Auto-remove after 5 seconds
  setTimeout(() => {
    if (alert.parentElement) {
      alert.remove();
    }
  }, 5000);
}

function displayStudentSummary(data) {
  const summaryBody = document.getElementById("summary-body");
  const studentResultContainer = document.getElementById("student-result");

  if (!summaryBody || !studentResultContainer) {
    console.error("Required DOM elements not found");
    return;
  }

  summaryBody.innerHTML = "";

  let result;
  if (data && data.body) {
    try {
      result = typeof data.body === 'string' ? JSON.parse(data.body) : data.body;
    } catch (error) {
      console.error("Parse error:", error);
      showAlert("Failed to parse grade data", "danger");
      return;
    }
  } else {
    result = data;
  }

  if (!result || !result.summary || !Array.isArray(result.summary)) {
    showAlert("No summary data available", "warning");
    return;
  }

  // Store the current data for updates
  currentStudentData = result;

  result.summary.forEach((grade, index) => {
    const row = document.createElement("tr");
    const dateStr = grade.timestamp
      ? new Date(grade.timestamp * 1000).toLocaleString()
      : "N/A";
    
    row.innerHTML = `
      <td>${escapeHtml(grade.student_id || "N/A")}</td>
      <td>${escapeHtml(grade.assignment_id || "N/A")}</td>
      <td>
        <span class="marks-display" id="summary-marks-${index}">${grade.total_marks !== undefined && grade.total_marks !== null ? grade.total_marks : "N/A"}</span>
        <input type="number" class="marks-input" id="summary-input-${index}" value="${grade.total_marks || 0}" style="display: none;" min="0" max="100">
      </td>
      <td>${escapeHtml(grade.evaluation_id || "N/A")}</td>
      <td>${escapeHtml(grade.qp_id || "N/A")}</td>
      <td>${escapeHtml(dateStr)}</td>
      <td>
        <button class="edit-marks-btn" onclick="toggleSummaryEditMode(${index})" data-index="${index}">Edit</button>
      </td>
    `;
    summaryBody.appendChild(row);
  });
  
  studentResultContainer.style.display = "block";
  

}

function toggleSummaryEditMode(index) {
  const marksDisplay = document.getElementById(`summary-marks-${index}`);
  const marksInput = document.getElementById(`summary-input-${index}`);
  const editBtn = document.querySelector(`[data-index="${index}"]`);
  
  if (!marksDisplay || !marksInput || !editBtn) {
    console.error("Summary edit elements not found");
    return;
  }
  
  if (marksDisplay.style.display !== "none") {
    // Switch to edit mode
    marksDisplay.style.display = "none";
    marksInput.style.display = "inline-block";
    marksInput.focus();
    editBtn.textContent = "Save";
    editBtn.classList.add("save-mode");
  } else {
    // Switch back to display mode and update the data
    const newValue = parseFloat(marksInput.value) || 0;
    marksDisplay.textContent = newValue;
    marksDisplay.style.display = "inline";
    marksInput.style.display = "none";
    editBtn.textContent = "Edit";
    editBtn.classList.remove("save-mode");
    
    // Update the stored data
    if (currentStudentData && currentStudentData.summary && currentStudentData.summary[index]) {
      currentStudentData.summary[index].total_marks = newValue;
    }
  }
}

// Function to calculate total marks from individual question marks
function calculateTotalMarks() {
  if (!currentStudentData || !currentStudentData.details) {
    return 0;
  }
  
  let totalMarks = 0;
  currentStudentData.details.forEach(question => {
    totalMarks += parseFloat(question.marks || 0);
  });
  
  return totalMarks;
}

// Function to update summary total marks when individual question marks change
function updateSummaryTotalMarks() {
  const newTotalMarks = calculateTotalMarks();
  
  // Update in current data
  if (currentStudentData && currentStudentData.summary && currentStudentData.summary[0]) {
    currentStudentData.summary[0].total_marks = newTotalMarks;
  }
  
  // Update in UI
  const summaryMarksDisplay = document.getElementById('summary-marks-0');
  const summaryMarksInput = document.getElementById('summary-input-0');
  
  if (summaryMarksDisplay) {
    summaryMarksDisplay.textContent = newTotalMarks;
  }
  if (summaryMarksInput) {
    summaryMarksInput.value = newTotalMarks;
  }
  
  // Show notification about auto-update
  showAlert(`Total marks automatically updated to ${newTotalMarks}`, "success");
}

// Function to toggle edit mode for individual question marks
function toggleQuestionEditMode(questionIndex) {
  const marksDisplay = document.getElementById(`question-marks-${questionIndex}`);
  const marksInput = document.getElementById(`question-input-${questionIndex}`);
  const editBtn = document.querySelector(`[data-question-index="${questionIndex}"]`);
  
  if (!marksDisplay || !marksInput || !editBtn) {
    console.error("Question edit elements not found");
    return;
  }
  
  if (marksDisplay.style.display !== "none") {
    // Switch to edit mode
    marksDisplay.style.display = "none";
    marksInput.style.display = "inline-block";
    marksInput.focus();
    editBtn.textContent = "Save";
    editBtn.classList.add("save-mode");
  } else {
    // Switch back to display mode and update the data
    const newValue = parseFloat(marksInput.value) || 0;
    const maxMarks = parseFloat(marksInput.getAttribute('data-max-marks')) || 100;
    
    // Validate marks don't exceed maximum
    if (newValue > maxMarks) {
      showAlert(`Marks cannot exceed maximum of ${maxMarks}`, "warning");
      marksInput.value = maxMarks;
      return;
    }
    
    if (newValue < 0) {
      showAlert("Marks cannot be negative", "warning");
      marksInput.value = 0;
      return;
    }
    
    marksDisplay.textContent = newValue;
    marksDisplay.style.display = "inline";
    marksInput.style.display = "none";
    editBtn.textContent = "Edit";
    editBtn.classList.remove("save-mode");
    
    // Update the stored data
    if (currentStudentData && currentStudentData.details && currentStudentData.details[questionIndex]) {
      currentStudentData.details[questionIndex].marks = newValue;
      
      // Automatically update total marks in summary
      updateSummaryTotalMarks();
    }
  }
}


async function handleUpdateMarks() {
  console.log('Update marks function called');

  if (!currentStudentData || !currentStudentData.summary) {
    showAlert("No data available to update", "warning");
    return;
  }

  // REPLACE the complex button finding logic with simple selector:
  const updateBtn = document.querySelector('.update-marks-button');

  if (!updateBtn) {
    console.error("Update button not found");
    showAlert("Update button not found", "warning");
    return;
  }

  const originalText = updateBtn.textContent;
  
  try {
    // Show loading state
    updateBtn.textContent = "Updating...";
    updateBtn.disabled = true;
    updateBtn.style.cursor = "not-allowed";

    console.log('Preparing data for update...');
    
    // Prepare the data for API call including both summary and details
    const updatedData = {
      
      operation: "updateMarks",
      summary: currentStudentData.summary.map(grade => ({
        student_id: grade.student_id,
        assignment_id: grade.assignment_id,
        evaluation_id: grade.evaluation_id,
        qp_id: grade.qp_id,
        total_marks: grade.total_marks,
        timestamp: grade.timestamp
      })),
      details: currentStudentData.details ? currentStudentData.details.map(question => ({
        question_number: question.question_number,
        subpart: question.subpart,
        marks: question.marks,
        max_marks: question.max_marks,
        timestamp: question.timestamp,
        evaluation_id: question.evaluation_id,
      })) : []
    };

    console.log('Data prepared:', updatedData);

    // Make API call to update marks
    const response = await updateMarksAPI(updatedData);
    
    console.log('API response:', response);
    
    if (response && (response.success || response.statusCode === 200)) {
      showAlert("All marks updated successfully!", "success");
      // Optionally refresh the data
      // await refreshStudentData();
    } else {
      throw new Error(response?.message || response?.error || "Update failed");
    }

  } catch (error) {
    console.error("Update error:", error);
    showAlert(`Failed to update marks: ${error.message}`, "danger");
  } finally {
    // Restore button state
    updateBtn.textContent = originalText;
    updateBtn.disabled = false;
    updateBtn.style.cursor = "pointer";
  }
}

// API call function for updating marks
async function updateMarksAPI(data) {
  console.log('Making API call to update marks...');
  console.log('API Endpoint:', CONFIG.API.UPDATE_ENDPOINT);
  console.log('Payload:', data);
  
  try {
    const payload = data // Add operation type for API to handle updates
    ;
    
    console.log('Final payload:', payload);
    
    const response = await fetch(CONFIG.API.UPDATE_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
        // Add authentication headers if needed
        // 'Authorization': `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify(payload)
    });

    console.log('Response status:', response.status);
    console.log('Response ok:', response.ok);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Response error text:', errorText);
      throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    console.log('API Response:', result);
    return result;

  } catch (error) {
    console.error('API call failed:', error);
    
    // If it's a network error, provide more specific information
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new Error('Network error: Please check your internet connection and try again.');
    }
    
    throw error;
  }
}

// Function to refresh data after update
async function refreshStudentData() {
  try {
    const queryParams = getQueryParams();
    const data = await makeAPIRequest(queryParams);
    displayStudentSummary(data);
    displayDetails(data);
  } catch (error) {
    console.error('Failed to refresh data:', error);
    showAlert('Failed to refresh data after update', 'warning');
  }
}

// Utility function to get auth token (customize based on your auth system)
function getAuthToken() {
  // Return your authentication token
  // This could be from memory variables, cookies, etc.
  return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
}

// Function to render content with proper formatting
function renderContent(text) {
  if (!text) return '';
  
  // Handle LaTeX format with sections
  if (text.includes('\\textbf{') && text.includes('}:} \\quad \\text{')) {
    const sections = text.match(/\[ \\textbf\{([^}]+)\}\:} \\quad \\text\{([^}]+)\} \]/g) || [];
    
    if (sections.length > 0) {
      const parsedHtml = sections.map(section => {
        const headingMatch = section.match(/\\textbf\{([^}]+)\}/);
        const contentMatch = section.match(/\\quad \\text\{([^}]+)\}/);
        
        const heading = headingMatch ? escapeHtml(headingMatch[1]) : '';
        let content = contentMatch ? contentMatch[1] : '';
        
        content = content.replace(/\\begin\{itemize\}(.*?)\\end\{itemize\}/gs, (match, items) => {
          const listItems = items.split('\\item').filter(item => item.trim());
          return `<ul>${listItems.map(item => `<li>${escapeHtml(item.trim())}</li>`).join('')}</ul>`;
        });
        
        content = content.replace(/\\([a-zA-Z]+)/g, '\\$1');
        content = content.replace(/\\\(([^)]+)\\\)/g, '$$1$');
        
        return `
          <div class="feedback-section">
            <h4>${heading}:</h4>
            <div class="feedback-content">${content}</div>
          </div>
        `;
      }).join('');
      
      return parsedHtml;
    }
  }
  
  // Process Markdown formatting
  let processedText = escapeHtml(text);
  
  processedText = processedText.replace(/^(\d+)\.\s*\*\*(.*?)\*\*/gm, '<br>$1. <strong>$2</strong>');
  processedText = processedText.replace(/^-\s*\*\*(.*?)\*\*/gm, '<br>- <strong>$1</strong>');
  processedText = processedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  processedText = processedText.replace(/^## (.*?)$/gm, '<br><h2>$1</h2>');
  processedText = processedText.replace(/^### (.*?)$/gm, '<br><h3>$1</h3>');
  
  return processedText;
}

// Function to display question details with editable marks
function displayDetails(data) {
  const questionsContainer = document.getElementById("questions-container");

  if (!questionsContainer) {
    console.error("Questions container not found");
    return;
  }

  questionsContainer.innerHTML = "";

  let result;
  if (data && data.body) {
    try {
      result = typeof data.body === 'string' ? JSON.parse(data.body) : data.body;
    } catch (error) {
      console.error("Parse error:", error);
      showAlert("Failed to parse details data", "danger");
      return;
    }
  } else {
    result = data;
  }

  if (!result || !result.details || !Array.isArray(result.details)) {
    console.log("No details available");
    return;
  }

  // Sort questions by question_number
  result.details.sort((a, b) => {
    const numA = parseInt(a.question_number) || 0;
    const numB = parseInt(b.question_number) || 0;
    
    if (numA !== numB) return numA - numB;
    
    if (a.subpart && b.subpart) {
      return a.subpart.localeCompare(b.subpart);
    } else if (a.subpart) {
      return 1;
    } else if (b.subpart) {
      return -1;
    }
    
    return 0;
  });

  result.details.forEach((question, questionIndex) => {
    const questionCard = document.createElement('div');
    questionCard.className = 'question-item';
    
    let timestamp = '';
    if (question.timestamp) {
      try {
        timestamp = new Date(question.timestamp * 1000).toLocaleString();
      } catch (e) {
        console.error("Invalid timestamp format", e);
        timestamp = '';
      }
    }
    
    questionCard.innerHTML = `
      <div class="question-header">
        <h3>Question ${escapeHtml(question.question_number || '')} ${question.subpart ? `(${escapeHtml(question.subpart)})` : ''}</h3>
      </div>
      
      <div class="question-meta">
        <span class="marks">
          Marks: 
          <span class="obtained-marks-container">
            <span class="marks-display" id="question-marks-${questionIndex}">${question.marks || 0}</span>
            <input type="number" 
                   class="marks-input" 
                   id="question-input-${questionIndex}" 
                   value="${question.marks || 0}" 
                   data-max-marks="${question.max_marks || 100}"
                   style="display: none;" 
                   min="0" 
                   max="${question.max_marks || 100}">
          </span>
          / <span class="max">${question.max_marks || 0}</span>
          <button class="edit-question-marks-btn" 
                  onclick="toggleQuestionEditMode(${questionIndex})" 
                  data-question-index="${questionIndex}"
                  style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Edit</button>
        </span>
        ${timestamp ? `<span class="timestamp">Answered on: ${escapeHtml(timestamp)}</span>` : ''}
      </div>

      <p class="question-text">${renderContent(question.question || 'Question not available')}</p>

      <div class="answer-section">
        <h4>Your Answer:</h4>
        <pre>${renderContent(question.student_answer || 'No answer provided')}</pre>
      </div>

      <div class="reasoning-section rubric">
        <h4>Feedback:</h4>
        <div class="feedback-container">${renderContent(question.feedback || 'No additional reasoning provided')}</div>
      </div>
    `;

    questionsContainer.appendChild(questionCard);
  });

  // Load MathJax if needed
  loadMathJax(questionsContainer);
}

function loadMathJax(container) {
  if (!window.MathJax) {
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        processEscapes: true
      },
      options: {
        enableMenu: false,
        processHtmlClass: 'math'
      }
    };
    
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js';
    script.async = true;
    document.head.appendChild(script);
    
    script.onload = function() {
      if (window.MathJax && window.MathJax.typeset) {
        window.MathJax.typeset([container]);
      }
    };
  } else {
    if (window.MathJax && window.MathJax.typeset) {
      window.MathJax.typeset([container]);
    }
  }
}

function setupNavLinkHighlighting() {
  // Implementation depends on your navigation structure
  console.log('Navigation highlighting setup');
}

async function loadAndDisplayData() {
  const queryParams = getQueryParams();
  
  if (!queryParams.student_id || !queryParams.assignment_id) {
    showAlert("Missing required parameters: student_id or assignment_id", "danger");
    return;
  }

  showLoading("student-loader-container");

  try {
    const data = await makeAPIRequest(queryParams);
    displayStudentSummary(data);
    displayDetails(data);
  } catch (error) {
    console.error("Error loading data:", error);
    showAlert(`Failed to load data: ${error.message}`, "danger");
  } finally {
    hideLoading("student-loader-container");
  }
}

// Initialize when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  console.log('DOM Content Loaded - Initializing application...');
  setupNavLinkHighlighting();
  loadAndDisplayData();
});

// Also add a fallback initialization in case DOMContentLoaded has already fired
if (document.readyState === 'loading') {
  // DOM is still loading
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  // DOM has already loaded
  initializeApp();
}

function initializeApp() {
  console.log('Initializing application...');
  setupNavLinkHighlighting();
  loadAndDisplayData();
}

</script> -->